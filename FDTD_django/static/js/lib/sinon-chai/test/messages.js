// Generated by CoffeeScript 1.9.2
(function() {
  "use strict";
  var sinon;

  sinon = require("sinon");

  describe("Messages", function() {
    describe("about call count", function() {
      it("should be correct for the base cases", function() {
        var spy;
        spy = sinon.spy();
        expect(function() {
          return spy.should.have.been.called;
        }).to["throw"]("expected spy to have been called at least once, but it was never called");
        expect(function() {
          return spy.should.have.been.calledOnce;
        }).to["throw"]("expected spy to have been called exactly once, but it was called 0 times");
        expect(function() {
          return spy.should.have.been.calledTwice;
        }).to["throw"]("expected spy to have been called exactly twice, but it was called 0 times");
        expect(function() {
          return spy.should.have.been.calledThrice;
        }).to["throw"]("expected spy to have been called exactly thrice, but it was called 0 times");
        expect(function() {
          return spy.should.have.callCount(1);
        }).to["throw"]("expected spy to have been called exactly once, but it was called 0 times");
        return expect(function() {
          return spy.should.have.callCount(4);
        }).to["throw"]("expected spy to have been called exactly 4 times, but it was called 0 times");
      });
      return it("should be correct for the negated cases", function() {
        var calledFourTimes, calledOnce, calledThrice, calledTwice;
        calledOnce = sinon.spy();
        calledTwice = sinon.spy();
        calledThrice = sinon.spy();
        calledFourTimes = sinon.spy();
        calledOnce();
        calledTwice();
        calledTwice();
        calledThrice();
        calledThrice();
        calledThrice();
        calledFourTimes();
        calledFourTimes();
        calledFourTimes();
        calledFourTimes();
        expect(function() {
          return calledOnce.should.not.have.been.called;
        }).to["throw"]("expected spy to not have been called");
        expect(function() {
          return calledOnce.should.not.have.been.calledOnce;
        }).to["throw"]("expected spy to not have been called exactly once");
        expect(function() {
          return calledTwice.should.not.have.been.calledTwice;
        }).to["throw"]("expected spy to not have been called exactly twice");
        expect(function() {
          return calledThrice.should.not.have.been.calledThrice;
        }).to["throw"]("expected spy to not have been called exactly thrice");
        expect(function() {
          return calledOnce.should.not.have.callCount(1);
        }).to["throw"]("expected spy to not have been called exactly once");
        return expect(function() {
          return calledFourTimes.should.not.have.callCount(4);
        }).to["throw"]("expected spy to not have been called exactly 4 times");
      });
    });
    describe("about call order", function() {
      it("should be correct for the base cases", function() {
        var spyA, spyB;
        spyA = sinon.spy();
        spyB = sinon.spy();
        spyA.displayName = "spyA";
        spyB.displayName = "spyB";
        expect(function() {
          return spyA.should.have.been.calledBefore(spyB);
        }).to["throw"]("expected spyA to have been called before function spyB() {}");
        return expect(function() {
          return spyB.should.have.been.calledAfter(spyA);
        }).to["throw"]("expected spyB to have been called after function spyA() {}");
      });
      return it("should be correct for the negated cases", function() {
        var spyA, spyB;
        spyA = sinon.spy();
        spyB = sinon.spy();
        spyA.displayName = "spyA";
        spyB.displayName = "spyB";
        spyA();
        spyB();
        expect(function() {
          return spyA.should.not.have.been.calledBefore(spyB);
        }).to["throw"]("expected spyA to not have been called before function spyB() {}");
        return expect(function() {
          return spyB.should.not.have.been.calledAfter(spyA);
        }).to["throw"]("expected spyB to not have been called after function spyA() {}");
      });
    });
    describe("about call context", function() {
      it("should be correct for the basic case", function() {
        var badContext, context, expected, spy;
        spy = sinon.spy();
        context = {};
        badContext = {
          x: "y"
        };
        spy.call(badContext);
        expected = "expected spy to have been called with {  } as this, but it was called with " + spy.printf("%t") + " instead";
        expect(function() {
          return spy.should.have.been.calledOn(context);
        }).to["throw"](expected);
        return expect(function() {
          return spy.getCall(0).should.have.been.calledOn(context);
        }).to["throw"](expected);
      });
      it("should be correct for the negated case", function() {
        var context, expected, spy;
        spy = sinon.spy();
        context = {};
        spy.call(context);
        expected = "expected spy to not have been called with {  } as this";
        expect(function() {
          return spy.should.not.have.been.calledOn(context);
        }).to["throw"](expected);
        return expect(function() {
          return spy.getCall(0).should.not.have.been.calledOn(context);
        }).to["throw"](expected);
      });
      return it("should be correct for the always case", function() {
        var badContext, context, expected, spy;
        spy = sinon.spy();
        context = {};
        badContext = {
          x: "y"
        };
        spy.call(badContext);
        expected = "expected spy to always have been called with {  } as this, but it was called with " + spy.printf("%t") + " instead";
        return expect(function() {
          return spy.should.always.have.been.calledOn(context);
        }).to["throw"](expected);
      });
    });
    describe("about calling with new", function() {
      it("should be correct for the basic case", function() {
        var expected, spy;
        spy = sinon.spy();
        spy();
        expected = "expected spy to have been called with new";
        expect(function() {
          return spy.should.have.been.calledWithNew;
        }).to["throw"](expected);
        return expect(function() {
          return spy.getCall(0).should.have.been.calledWithNew;
        }).to["throw"](expected);
      });
      it("should be correct for the negated case", function() {
        var expected, spy;
        spy = sinon.spy();
        new spy();
        expected = "expected spy to not have been called with new";
        expect(function() {
          return spy.should.not.have.been.calledWithNew;
        }).to["throw"](expected);
        return expect(function() {
          return spy.getCall(0).should.not.have.been.calledWithNew;
        }).to["throw"](expected);
      });
      return it("should be correct for the always case", function() {
        var expected, spy;
        spy = sinon.spy();
        new spy();
        spy();
        expected = "expected spy to always have been called with new";
        return expect(function() {
          return spy.should.always.have.been.calledWithNew;
        }).to["throw"](expected);
      });
    });
    describe("about call arguments", function() {
      it("should be correct for the basic cases", function() {
        var spy;
        spy = sinon.spy();
        spy(1, 2, 3);
        expect(function() {
          return spy.should.have.been.calledWith("a", "b", "c");
        }).to["throw"]("expected spy to have been called with arguments a, b, c\n    spy(1, 2, 3)");
        expect(function() {
          return spy.should.have.been.calledWithExactly("a", "b", "c");
        }).to["throw"]("expected spy to have been called with exact arguments a, b, c\n    spy(1, 2, 3)");
        expect(function() {
          return spy.should.have.been.calledWithMatch(sinon.match("foo"));
        }).to["throw"]("expected spy to have been called with arguments matching match(\"foo\")\n    spy(1, 2, 3)");
        expect(function() {
          return spy.getCall(0).should.have.been.calledWith("a", "b", "c");
        }).to["throw"]("expected spy to have been called with arguments a, b, c\n    spy(1, 2, 3)");
        expect(function() {
          return spy.getCall(0).should.have.been.calledWithExactly("a", "b", "c");
        }).to["throw"]("expected spy to have been called with exact arguments a, b, c\n    spy(1, 2, 3)");
        return expect(function() {
          return spy.getCall(0).should.have.been.calledWithMatch(sinon.match("foo"));
        }).to["throw"]("expected spy to have been called with arguments matching match(\"foo\")\n    spy(1, 2, 3)");
      });
      it("should be correct for the negated cases", function() {
        var spy;
        spy = sinon.spy();
        spy(1, 2, 3);
        expect(function() {
          return spy.should.not.have.been.calledWith(1, 2, 3);
        }).to["throw"]("expected spy to not have been called with arguments 1, 2, 3");
        expect(function() {
          return spy.should.not.have.been.calledWithExactly(1, 2, 3);
        }).to["throw"]("expected spy to not have been called with exact arguments 1, 2, 3");
        expect(function() {
          return spy.should.not.have.been.calledWithMatch(sinon.match(1));
        }).to["throw"]("expected spy to not have been called with arguments matching match(1)");
        expect(function() {
          return spy.getCall(0).should.not.have.been.calledWith(1, 2, 3);
        }).to["throw"]("expected spy to not have been called with arguments 1, 2, 3");
        expect(function() {
          return spy.getCall(0).should.not.have.been.calledWithExactly(1, 2, 3);
        }).to["throw"]("expected spy to not have been called with exact arguments 1, 2, 3");
        return expect(function() {
          return spy.getCall(0).should.not.have.been.calledWithMatch(sinon.match(1));
        }).to["throw"]("expected spy to not have been called with arguments matching match(1)");
      });
      return it("should be correct for the always cases", function() {
        var expected, expectedExactly, expectedMatch, spy;
        spy = sinon.spy();
        spy(1, 2, 3);
        spy("a", "b", "c");
        expected = "expected spy to always have been called with arguments 1, 2, 3\n    spy(1, 2, 3)\n" + "    spy(a, b, c)";
        expect(function() {
          return spy.should.always.have.been.calledWith(1, 2, 3);
        }).to["throw"](expected);
        expectedExactly = "expected spy to always have been called with exact arguments 1, 2, 3\n" + "    spy(1, 2, 3)\n    spy(a, b, c)";
        expect(function() {
          return spy.should.always.have.been.calledWithExactly(1, 2, 3);
        }).to["throw"](expectedExactly);
        expectedMatch = "expected spy to always have been called with arguments matching match(1)\n" + "    spy(1, 2, 3)\n    spy(a, b, c)";
        return expect(function() {
          return spy.should.always.have.been.calledWithMatch(sinon.match(1));
        }).to["throw"](expectedMatch);
      });
    });
    describe("about returning", function() {
      it("should be correct for the basic case", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.have.returned(2);
        }).to["throw"]("expected spy to have returned 2");
        return expect(function() {
          return spy.getCall(0).should.have.returned(2);
        }).to["throw"]("expected spy to have returned 2");
      });
      it("should be correct for the negated case", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.not.have.returned(1);
        }).to["throw"]("expected spy to not have returned 1");
        return expect(function() {
          return spy.getCall(0).should.not.have.returned(1);
        }).to["throw"]("expected spy to not have returned 1");
      });
      return it("should be correct for the always case", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        return expect(function() {
          return spy.should.always.have.returned(2);
        }).to["throw"]("expected spy to always have returned 2");
      });
    });
    describe("about throwing", function() {
      it("should be correct for the basic cases", function() {
        var spy, throwingSpy;
        spy = sinon.spy();
        throwingSpy = sinon.spy.create(function() {
          throw new Error();
        });
        spy();
        swallow(throwingSpy);
        expect(function() {
          return spy.should.have.thrown();
        }).to["throw"]("expected spy to have thrown");
        expect(function() {
          return spy.getCall(0).should.have.thrown();
        }).to["throw"]("expected spy to have thrown");
        expect(function() {
          return throwingSpy.should.have.thrown("TypeError");
        }).to["throw"]("expected spy to have thrown TypeError");
        expect(function() {
          return throwingSpy.getCall(0).should.have.thrown("TypeError");
        }).to["throw"]("expected spy to have thrown TypeError");
        expect(function() {
          return throwingSpy.should.have.thrown({
            message: "x"
          });
        }).to["throw"]('expected spy to have thrown { message: "x" }');
        return expect(function() {
          return throwingSpy.getCall(0).should.have.thrown({
            message: "x"
          });
        }).to["throw"]('expected spy to have thrown { message: "x" }');
      });
      it("should be correct for the negated cases", function() {
        var error, spy;
        error = new Error("boo!");
        spy = sinon.spy.create(function() {
          throw error;
        });
        swallow(spy);
        expect(function() {
          return spy.should.not.have.thrown();
        }).to["throw"]("expected spy to not have thrown");
        expect(function() {
          return spy.getCall(0).should.not.have.thrown();
        }).to["throw"]("expected spy to not have thrown");
        expect(function() {
          return spy.should.not.have.thrown("Error");
        }).to["throw"]("expected spy to not have thrown Error");
        expect(function() {
          return spy.getCall(0).should.not.have.thrown("Error");
        }).to["throw"]("expected spy to not have thrown Error");
        expect(function() {
          return spy.should.not.have.thrown(error);
        }).to["throw"]("expected spy to not have thrown Error: boo!");
        return expect(function() {
          return spy.getCall(0).should.not.have.thrown(error);
        }).to["throw"]("expected spy to not have thrown Error: boo!");
      });
      return it("should be correct for the always cases", function() {
        var spy, throwingSpy;
        spy = sinon.spy();
        throwingSpy = sinon.spy.create(function() {
          throw new Error();
        });
        spy();
        swallow(throwingSpy);
        expect(function() {
          return spy.should.have.always.thrown();
        }).to["throw"]("expected spy to always have thrown");
        expect(function() {
          return throwingSpy.should.have.always.thrown("TypeError");
        }).to["throw"]("expected spy to always have thrown TypeError");
        return expect(function() {
          return throwingSpy.should.have.always.thrown({
            message: "x"
          });
        }).to["throw"]('expected spy to always have thrown { message: "x" }');
      });
    });
    describe("when used on a non-spy/non-call", function() {
      var notSpy;
      notSpy = function() {};
      it("should be informative for properties", function() {
        return expect(function() {
          return notSpy.should.have.been.called;
        }).to["throw"](TypeError, /not a spy/);
      });
      return it("should be informative for methods", function() {
        return expect(function() {
          return notSpy.should.have.been.calledWith("foo");
        }).to["throw"](TypeError, /not a spy/);
      });
    });
    return it("should not trigger getters for passing assertions", function() {
      var getterCalled, obj, spy;
      obj = {};
      getterCalled = false;
      Object.defineProperty(obj, "getter", {
        get: function() {
          return getterCalled = true;
        },
        enumerable: true
      });
      spy = sinon.spy();
      spy(obj);
      spy.should.have.been.calledWith(obj);
      return expect(getterCalled).to.be["false"];
    });
  });

}).call(this);

//# sourceMappingURL=messages.js.map
