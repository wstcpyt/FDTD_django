// Generated by CoffeeScript 1.9.2
(function() {
  "use strict";
  var sinon;

  sinon = require("sinon");

  describe("Calling with new", function() {
    var spy;
    spy = null;
    beforeEach(function() {
      return spy = sinon.spy();
    });
    describe("calledWithNew", function() {
      it("should throw an assertion error if the spy is never called", function() {
        return expect(function() {
          return spy.should.have.been.calledWithNew;
        }).to["throw"](AssertionError);
      });
      it("should throw an assertion error if the spy is called without `new`", function() {
        spy();
        expect(function() {
          return spy.should.have.been.calledWithNew;
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.getCall(0).should.have.been.calledWithNew;
        }).to["throw"](AssertionError);
      });
      it("should not throw if the spy is called with `new`", function() {
        new spy();
        expect(function() {
          return spy.should.have.been.calledWithNew;
        }).to.not["throw"]();
        return expect(function() {
          return spy.getCall(0).should.have.been.calledWithNew;
        }).to.not["throw"]();
      });
      return it("should not throw if the spy is called with `new` and also without `new`", function() {
        spy();
        new spy();
        expect(function() {
          return spy.should.have.been.calledWithNew;
        }).to.not["throw"]();
        return expect(function() {
          return spy.getCall(1).should.have.been.calledWithNew;
        }).to.not["throw"]();
      });
    });
    return describe("always calledWithNew", function() {
      it("should throw an assertion error if the spy is never called", function() {
        expect(function() {
          return spy.should.always.have.been.calledWithNew;
        }).to["throw"](AssertionError);
        expect(function() {
          return spy.should.have.always.been.calledWithNew;
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.should.have.been.always.calledWithNew;
        }).to["throw"](AssertionError);
      });
      it("should throw an assertion error if the spy is called without `new`", function() {
        spy();
        expect(function() {
          return spy.should.always.have.been.calledWithNew;
        }).to["throw"](AssertionError);
        expect(function() {
          return spy.should.have.always.been.calledWithNew;
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.should.have.been.always.calledWithNew;
        }).to["throw"](AssertionError);
      });
      it("should not throw if the spy is called with `new`", function() {
        new spy();
        expect(function() {
          return spy.should.always.have.been.calledWithNew;
        }).to.not["throw"]();
        expect(function() {
          return spy.should.have.always.been.calledWithNew;
        }).to.not["throw"]();
        return expect(function() {
          return spy.should.have.been.always.calledWithNew;
        }).to.not["throw"]();
      });
      return it("should throw an assertion error if the spy is called with `new` and also without `new`", function() {
        spy();
        new spy();
        expect(function() {
          return spy.should.always.have.been.calledWithNew;
        }).to["throw"](AssertionError);
        expect(function() {
          return spy.should.have.always.been.calledWithNew;
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.should.have.been.always.calledWithNew;
        }).to["throw"](AssertionError);
      });
    });
  });

}).call(this);

//# sourceMappingURL=callingWithNew.js.map
