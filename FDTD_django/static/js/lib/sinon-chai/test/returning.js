// Generated by CoffeeScript 1.9.2
(function() {
  "use strict";
  var sinon;

  sinon = require("sinon");

  describe("Returning", function() {
    describe("returned", function() {
      it("should throw an assertion error if the spy does not return the correct value", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.have.returned(2);
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.getCall(0).should.have.returned(2);
        }).to["throw"](AssertionError);
      });
      it("should not throw if the spy returns the correct value", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.have.returned(1);
        }).to.not["throw"]();
        return expect(function() {
          return spy.getCall(0).should.have.returned(1);
        }).to.not["throw"]();
      });
      return it("should not throw if the spy returns the correct value amongst others", function() {
        var spy, values;
        values = [1, 2, 3];
        spy = sinon.spy.create(function() {
          return values[spy.callCount - 1];
        });
        spy();
        spy();
        spy();
        expect(function() {
          return spy.should.have.returned(1);
        }).to.not["throw"]();
        return expect(function() {
          return spy.getCall(0).should.have.returned(1);
        }).to.not["throw"]();
      });
    });
    return describe("always returned", function() {
      it("should throw an assertion error if the spy does not return the correct value", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.always.have.returned(2);
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.should.have.always.returned(2);
        }).to["throw"](AssertionError);
      });
      it("should not throw if the spy returns the correct value", function() {
        var spy;
        spy = sinon.spy.create(function() {
          return 1;
        });
        spy();
        expect(function() {
          return spy.should.have.always.returned(1);
        }).to.not["throw"]();
        return expect(function() {
          return spy.should.always.have.returned(1);
        }).to.not["throw"]();
      });
      return it("should throw an assertion error if the spy returns the correct value amongst others", function() {
        var spy, values;
        values = [1, 2, 3];
        spy = sinon.spy.create(function() {
          return values[spy.callCount - 1];
        });
        spy();
        spy();
        spy();
        expect(function() {
          return spy.should.always.have.returned(1);
        }).to["throw"](AssertionError);
        return expect(function() {
          return spy.should.have.always.returned(1);
        }).to["throw"](AssertionError);
      });
    });
  });

}).call(this);

//# sourceMappingURL=returning.js.map
