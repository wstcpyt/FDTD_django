// Generated by CoffeeScript 1.9.2
(function() {
  "use strict";
  var sinon;

  sinon = require("sinon");

  describe("Call order", function() {
    var spy1, spy2;
    spy1 = null;
    spy2 = null;
    beforeEach(function() {
      spy1 = sinon.spy();
      return spy2 = sinon.spy();
    });
    describe("spy1 calledBefore spy2", function() {
      it("should throw an assertion error when neither spy is called", function() {
        return expect(function() {
          return spy1.should.have.been.calledBefore(spy2);
        }).to["throw"](AssertionError);
      });
      it("should not throw when only spy 1 is called", function() {
        spy1();
        return expect(function() {
          return spy1.should.have.been.calledBefore(spy2);
        }).to.not["throw"]();
      });
      it("should throw an assertion error when only spy 2 is called", function() {
        spy2();
        return expect(function() {
          return spy1.should.have.been.calledBefore(spy2);
        }).to["throw"](AssertionError);
      });
      it("should not throw when spy 1 is called before spy 2", function() {
        spy1();
        spy2();
        return expect(function() {
          return spy1.should.have.been.calledBefore(spy2);
        }).to.not["throw"]();
      });
      return it("should throw an assertion error when spy 1 is called after spy 2", function() {
        spy2();
        spy1();
        return expect(function() {
          return spy1.should.have.been.calledBefore(spy2);
        }).to["throw"](AssertionError);
      });
    });
    return describe("spy1 calledAfter spy2", function() {
      it("should throw an assertion error when neither spy is called", function() {
        return expect(function() {
          return spy1.should.have.been.calledAfter(spy2);
        }).to["throw"](AssertionError);
      });
      it("should throw an assertion error when only spy 1 is called", function() {
        spy1();
        return expect(function() {
          return spy1.should.have.been.calledAfter(spy2);
        }).to["throw"](AssertionError);
      });
      it("should throw an assertion error when only spy 2 is called", function() {
        spy2();
        return expect(function() {
          return spy1.should.have.been.calledAfter(spy2);
        }).to["throw"](AssertionError);
      });
      it("should throw an assertion error when spy 1 is called before spy 2", function() {
        spy1();
        spy2();
        return expect(function() {
          return spy1.should.have.been.calledAfter(spy2);
        }).to["throw"](AssertionError);
      });
      return it("should not throw when spy 1 is called after spy 2", function() {
        spy2();
        spy1();
        return expect(function() {
          return spy1.should.have.been.calledAfter(spy2);
        }).to.not["throw"]();
      });
    });
  });

}).call(this);

//# sourceMappingURL=callOrder.js.map
